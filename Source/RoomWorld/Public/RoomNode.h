

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "RoomTypes.h"
#include "RoomNode.generated.h"


/** 
 * Base class for nodes in RoomWorld 
 * Allows snapping using node sockets
 */
UCLASS(Abstract, BlueprintType, ClassGroup = (RoomWorld))
class ROOMWORLD_API ARoomNode : public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY()
	ARoomManager* Manager;

	UPROPERTY(EditDefaultsOnly, Category = Node)
	bool bCanMoveInEditor;

	/** Node color. Autogenerated if set to zero */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, NonPIEDuplicateTransient, Category = Node)
	FLinearColor NodeColor;

	UPROPERTY(EditDefaultsOnly, Category = Socket)
	TSubclassOf<class URoomSocket> SocketClass;

	/** Default handle class when socket does not provide override. Disables handles when null */
	UPROPERTY(EditDefaultsOnly, Category = Socket)
	TSubclassOf<class ARoomSocketHandle> SocketHandleClass;

	UPROPERTY(VisibleAnywhere, Instanced, NonPIEDuplicateTransient, Category = Socket)
	TMap<FName, URoomSocket*> Sockets;

	UPROPERTY()
	FTransform InitialPosition;

public:	
	ARoomNode();
	virtual void PostLoad() override;
	virtual void PostInitializeComponents() override;
	virtual void OnConstruction(const FTransform& Transform) override;
	virtual void Destroyed() override;


public:
	UFUNCTION(BlueprintCallable, Category = Room)
	virtual bool CanMove() const { return true; }

	UFUNCTION(BlueprintCallable, Category = Room)
	ARoomManager* GetManager() const { return Manager; }


	/** Used to create sockets. empty by default */
	virtual const TMap<FName, FSocketData>& GetSocketData() const;

	virtual void RebuildSockets();

public:

	UFUNCTION(BlueprintCallable, Category = Room)
	TArray<FName> GetRoomSocketNames() const;

	UFUNCTION(BlueprintCallable, Category = Room)
	TArray<URoomSocket*> GetRoomSockets() const;

	UFUNCTION(BlueprintCallable, Category = Room)
	bool GetRoomSocket(FName Name, URoomSocket*& Socket) const;
	

	


public:

	/** Snaps room with target room aligning sockets back to back. Can be stobbed by CanMove() Returns true on success.  */
	UFUNCTION(BlueprintCallable, Category = Room)
	bool SnapWithNode(FName Socket, ARoomNode* TargetNode, FName TargetSocket);

	UFUNCTION(BlueprintCallable, Category = Room)
	void SnapAllConnectedNodes();

protected:
	virtual void OnSnapped(FName Socket, ARoomNode* OtherNode, FName OtherSocket);

	UFUNCTION(BlueprintImplementableEvent)
	void ReceiveWasSnapped(FName Socket, ARoomNode* OtherNode, FName OtherSocket);


	/*--------------------------------------------
	 	Utility
	 *--------------------------------------------*/
public:

	/** Collects connected nodes and filters by class. Returns true if at leas one node has passed filter */
	UFUNCTION(BlueprintCallable, Category = Room, meta = (DisplayName = "GetConnectedNodes", DynamicOutputParam = Nodes, DeterminesOutputType = ClassFilter))
	bool BP_GetConnectedNodes(TArray<ARoomNode*>& Nodes, TSubclassOf<ARoomNode> ClassFilter) { return GetConnectedNodes(Nodes, ClassFilter); }
	bool GetConnectedNodes(TArray<ARoomNode*>& Nodes, TSubclassOf<ARoomNode> ClassFilter) const;


public:
	template<typename Func>
	void ForEachSocket(Func InFunc) const
	{
		for (auto& Pair : Sockets)
		{
			if (URoomSocket* Socket = Pair.Value)
			{
				InFunc(Socket);
			}
		}
	}

};

